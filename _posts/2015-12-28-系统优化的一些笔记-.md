---
layout: post
title: 如何优化一个系统
---


----------------------------

#####摘要
优化系统的目的：对于一个系统，主要有3个方面，1.系统的响应时间，对于用户的请求在尽可能短的时间安内返回执行结果，2.系统的吞吐率，在一个固定的时间内能够响应尽可能多的请求，3.系统的可用性，在系统的访问的高峰期的时候，系统依旧能够响应用户的请求。这三者之间是一个矛盾的，为了提高系统的可用性，会实现一种重试机制，这种会增加了系统的响应时间，降低了系统的吞吐率。【降低响应时间和提高吞吐率的实现方式】
遇到的问题的挑战：1，日益增长的用户数量 ； 2.日益复杂的业务；3.迅速增长的数据。在工程上主要保证了三点：1.对于系统中的每一个服务的访问时间的95线尽可能的低；2.不断提高的系统吞吐率3.在流量高峰时期的服务的可用性。
本文通过模式的方式来进行介绍，首先是模式的介绍，然后是介绍常见的性能恶化的模式，一些常见的问题导致系统中性能的恶化，以及形成的恶性循环，接着是性能优化模式，这些模式能够是系统实现上面的三个目标。

----------------------------
#####介绍
使用模式的方式来介绍性能优化。模式的就是指一些问题的解决方案，首先提出问题，然后分析问题，解决问题，最后对当前的解决方案中的一些优点和遇到的弊端。为每一个模式提供一个贴切的名称，便于交流和快速理解。对于系统中的每一个模式都通过`命名  --> 原理和动机  --> 具体案例  --> 优点和缺点`来介绍模式。模式介绍的优点：通过介绍遇到的一些问题，使得读者能够尽可能多的理解上下文，能够对需要描述的问题有更深的理解，在了解模式的同时，能够对如何使用这个模式有更好的理解。

#####案例说明
对于一些案例都是经过了简化和抽象，便于描述一类问题。
#####设计原则
对于一些模式可能会和一些优秀的设计原则相悖，模式需要解决的问题也可以避免，但是这个问题的出现本身就是合理的，我们在介绍模式的时候是为了解决问题，而不是去想方法去绕过这个问题，任何设计原则都是一些列的 妥协的结果。
#####最小可用原则
最小可用原则（快速接入原则）关键：1.强调快速接入快速完成，2.保证核心功能可用。这是被普遍运用的一个原则，主要是缩短开发的周期，增加试错的机会，避免过度设计。为了快速接入就要尽可能的使用现有的解决方案或者是设计系统。通过尽可能小对现有的系统的修改能够解决现有的问题。过度的快速接入带来的问题是重构的风险。

#####经济原则
经济原则和最小可用原则，他们之间的关注点是不一样的，软件的开发有这样几个时期：预研，设计，开发，测试，运行，维护等阶段。最小接入原则主要是预研阶段，而经济原则贯穿于整个系统开发的始终，或者是系统开发的所有周期中的某几个，例如系统的运行阶段的经济原则主要是：缓存的消耗，cpu的消耗，磁盘的消耗，带宽的消耗等等。设计阶段的经济原则要求避免过度设计；对于开发阶段主要是关注代码复用，工程师的资源复用等。
#####代码复用原则
代码复用分为两种，首先是直接使用现有的解决方案或者是调用现有的共享库，称为方案复用，第二种是直接在现有的代码库中进行开发，也称之为共用代码库。
 - 方案复用  是一种实用主义的手法，最大限度的使用现有的解决方案，即使这个解决方案并不是最好的。方案的形式可以是共享库，也可以是现有的服务。一些服务并不是解决当期问题的最优解，但是依然调用了当前的服务。方案复用最大的有点就是提高了生产效率。例如：java之所以能够得到如此广泛的使用，原因之一就是有大量的可以重复利用的开源库。java中的write  one  run anywhere。是java最核心的设计理念之一。
 - 共用代码库  在原有的代码中添加代码，完成所有的功能。新的功能能够无边界的调用旧有的系统中的功能。旧的代码的库中的各种运行编译，测试，配置环境皆可复用。主要有两方面的好处：1.充分利用代码中已经有的基础设施，能够快速接入新业务。2.直接调用原油代码中的基础的功能或原语，避免了网络或进程间调用的开销，性能更好。

从设计的角度来讲，方案复用类似于SOA,就是将各种依赖的服务包装成为服务向外提供，共用代码Monolithic Architecture非常的接近。简而言之，方案编程倾向于面向接口编程，设计出可重用的组件(Liberary 或者 service)，通过分层来组织各层的组件来实现一个良好的系统体系结构。与之相对应的，Monolith Architeture则倾向于在一套代码库中开发，通过直接调用代码中的基础功能或者是原语来实现性能的优化和快速的迭代.Monolith Architecure 存在一些问题，1.缺乏美感 ， 2.很难重构，3.过早优化4.不可重用，微服务是很多的公司使用的方式，也有一些公式使用Monolithic Architecture也有公司使用，Linx的内核也是使用的后者。

#####奥卡姆剃刀原则
系统的编写需要遵守奥卡姆剃刀原则，如果一个功能模块不是必须的就不要，如果一段代码不是必须要写就不写。主要是系统中的代码就是写的越多，出错的概率就越大，所以能不写就不写。
奥卡姆剃刀原则和最小可用原则有所区别。最小可用原则主要是菜品的MVP阶段。奥卡姆原则主要是指系统设计和代码的编写阶段。
#####性能恶化模式
在讲解性能优化模式之前，有必要先探讨一下心能恶化模式:
1.很多性能优化模式是为了避免系统进入西能恶化模式
2.不同的性能优化模式能够避免同一种性能恶化问题。
3.同一种性能优化模式能够在系统的不同的阶段解决不同的性能恶化问题。

#######长请求拥塞反模式
单次请求时延长爾导致系统的性能恶化或者崩溃。对于多线程的场景，如果请求的时间延长会使得线程堆积，内存使用增加，最终可能带来3种问题：
1. 线程数目的增加导致多个线程之间竞争cpu，导致不同的线程不断的切换cpu的上下文，反过来进一步延长单次请求的时间。
2. 线程数量增多以及线程中缓存变大，内存的消耗变多，对于java的线程导致了频繁的full  gc，反过来增加单次请求的响应时间。
3. 内存使用增多，会使得操作系统的内存不足，必须使用swap内外部换页，可以导致服务测底的崩溃。

长请求拥塞导致的系统的性能恶化非常的明显，典型的场景:某业务复杂的业务系统依赖多个服务，其中某个服务的响应时间变长，随着系统整体响应时间变长，进而出现cpu，内存，swap报警等问题。系统进入长请求反模式的时候典型的问题：被依赖的服务的可用性降低，响应时间变长，服务的某段计算逻辑时间变长。

#######多次请求杠杆反模式：
每一个层次的服务依赖于多个服务的时候，当用户请求第一个服务的时候，会调用多个服务。当调用第二层的时候会调用更多的服务， 就想一个杠杆一项，底层的服务可能会需要处理非常多的请求，这些服务往往会成为整个系统的瓶颈。与此同时大量的请求也会给网络带来压力，特别是请求数量很大的情况，网络会成为系统彻底崩溃的导火索。一是系统需要处理非常多的请求，导致系统的压力大，其二是大量的请求带来的网络的压力，导致系统崩溃。
多次请求杠杆导致性能恶化是非常常见的问题，例如：推荐系统，一个用户的请求会有多个算法参与，每个算法会找回多个列表单元，每个单元会有多个字段，这些字段分布在不同的机器上，所以一次客户端的请求会形成成千上万的用户。在平常的时候能够正常工作的服务，在系统压力巨大的时候可用性将会降低。

########反复缓存反模式：
我们为了降低访问的响应时间，会想系统中添加缓存。缓存数据越多，命中率就越高，平均响应时间就会越短。有的时候为了降低系统的响应时间，有些开发者往往会无节制的将数据添加到缓存中，在正常的情况下系统的响应时间会大幅度的降低。但是内存中添加了太多的数据的时候容易将系统中的内存填满，导致触发fullGC，内存缓存就会被清空，然后接着就会再次填充内存。然后系统不断的发生fullGC，然后缓存就再次进行填满。【在开发的过程中不要将一些数据缓存在本地内存中】。
反复的缓存导致的系统资源的恶化的原因是无节制的使用本地的缓存。缓存使用的指导原则是：在使用本地缓存的时候，必须全局的考虑，精细规划，取保数据完全缓存的情况下，系统仍然不会频繁的full GC。为了解决这种问题，必须严格控制缓存的大小，甚至是废除缓存。

--------------------
#####性能优化模式
####水平分割模式
#####原理与动机
典型的服务运行流程会包括四个环节：接受请求，获取数据，处理数据，返回结果。在一尺请求中，获取数据和处理数据往往会发生多次。在完全串行的系统中， 一次请求的时间由以下的部分组成。
`一次请求的总的响应时间 = 解释请求耗时 + ∑（获取数据时间 + 处理数据耗时） +组装返回结果耗时`
大部分的时间都是消耗在了获取数据和处理数据的耗时上了，即获取数据和处理数据上面了。一般的系统分为两种，一种是计算密集性系统，二是 计算非密集型系统。对于计算非密集型的系统，大部分的时间都花费在了获取数据了，对于系统中的数据，可能存放的地方主要是本地缓存，远端缓存，数据库中和远端服务。三者当中的对于远端的服务的调用和数据库的调用所耗费的时间最多。特别是需要对此进行多次远端调用的系统，串行调用所带来的累加效应将会极大的延长单次请求的响应时间。如果能够对多个不同的业务请求进行并发处理的时候，请求的总的耗时会大大降低。
解决方式：将当前的系统中的请求的流程切分为必须相互依赖的多个部分，每个部分包含了多个独立的业务处理（其中包括了计算和数据的获取）。完成切分后各个大的部分顺序执行，而各个大的部分中的处理需要并行的执行。降低单个部分耗时一般有两种思路：1.将部分内部的在一次尝试水平的分割2.对于一些可以放在任意部分中的操作放在耗时最长的部分中进行并行处理，避免耗时较短的部分被拉长。
水平分割模式能够很好的降低系统的平均响应时间，同时可以降低95线。分割水平模式往往能够大幅度的提高系统的吞吐量以及高峰时期系统可用性，并大大降低系统进入长请求拥塞反模式的概率。
######具体的案例
常常需要为用户提供优质的个性化的列表服务，每一次类表服务都会有多个算法参与，而每一个算法基本都采用了"召回   特征获取  计算"的模式。各个算法之间采用顺序执行的方式，伴随着业务的发展，算法越来越多，随之而来的是用户请求的响应时间越来越多。这很容易引发长请求的拥塞的反模式。
采取一下的一些优化的措施：
```
1. 算法之间并行计算
2. 每个算法内部，多次特征的获取使用并行的方式执行。
3. 在调度线程进行调度的时候，耗时最长的线程最先调度，最后处理

```
######缺点和优点
对成熟的系统进行水平切割，意味着对原来的系统进行重大的重构，工程师必须对业务和系统非常的熟悉，所以需要谨慎的使用。水平的切割有两方面的难点：
1. 并行计算将原本单一的线程的工作分配个多个线程执行，提高了系统的复杂程度。而多线程所引入的安全问题让系统变得脆弱。多线程的测试的难度会增加，因此姚保证服务的一致性会很有难度。
2. 对于将一个单线程的工作转变为一个多线程的实现，原本使用单线程实现的代码的 各种依赖会耦合在一起，需要将原本的代码分到不同的线程中需要开发额外的开发量。这违背了奥卡姆剃刀的愿这。
在一些情况下，水平切割带来的性能的优化并不明显：
1，如果系统中的多个服务之间，如果有一个服务的执行的时间非常长而其他的时间非常短的时候，导致的问题是使用水平分割的效果将会非常的差。

水平分割的方式能够很大的程度上降低系统的95线，能够显著的提高系统的性能。降低系统在流量高峰期的时候的崩溃的概率。水平进行分割比较的复杂，但是水平分割易于理解，只要熟悉业务就能够很好的实现。

####垂直分割
#####原理与动机
当需求越来越多的时候，系统图中往往会有越来越多的代码像是却不相关的代码，当系统的功能变得越来越复杂，而系统也会变得越来越脆落.这种脆落带来的问题是响应时间的变慢和吞吐率的降低或者是可用性的降低。主要的原因是系统中的两种冲突：资源使用冲突，和可用性不一致的冲突。
 资源使用的冲突是系统变得脆落的一个重要因素。不同的业务并行于一个并行的系统中意味着资源的共享，也一位之资源的使用的冲突。可能除向的冲突包括：CPU，内存，网络 ，I/O等：一种业务功能无论调用的两多么的小，一定会带来一些开销，对于大量的缓存的开销的业务会带来的问题是带来大量的缓存的开销，从而导致系统中大量的反复缓存反模式。对于计算密集性请求，当发生冲突的时候响应时间将会变慢，从而使得系统进入长请求拥塞反模式的可能。
 
 不加区分的将不同的不同可用性的业务需求放在同一个系统中的时候，会导致系统的整体可用性的降低。当不同的业务功能柔和在同一个运营系统的时候，在运营和机器成眠对不同业务的可用性，可靠性进行调配将会变得非常的困难。但是，在高峰流量导致系统濒临崩溃的时候最有效的手段就是运维，当运维也失效的时候导致的问题就是当前的系统的可用性降低。
 
 垂直分割的思路就是将系统按照不同的业务功能进行风格，主要有两种分割模式：部署垂直分割和代码垂直分割。部署垂直分割主要是按照可用性要救将系统进行等价的分类，不同可用性业务部署子啊不同的机器上，高可用性的机器部署在一台机器上,避免一些可用性低的代码拖累；代码的垂直部署就是让不同的业务系统不共享代码，彻底解决系统资源使用冲突问题。
 
 ######具体案例
 美团的推荐系统，客户端，的多个页面中都有推荐列表。虽然不同的推荐产品需求来源不同，但是为了实现快速的接入，基于共用代码的原则，所有的推荐业务共享一套推荐代码，同一套的部署。在一段时间内，push推荐和首页的猜你喜欢的资源消耗巨大，。特别是在push推荐的高峰时刻，cpu和内存频繁报警，系统不停的full  GC，照成美团用户进入客户端时候，首页出现大片的空白。
 
 ######解决方案
 对系统进行分析，得出两个结论。【主要是分析当前系统中的各个系统的重要程度 ，对于重要的系统给于优先的资源 以及 查看各个系统中cpu和内存 io等资源的冲突】
 1.首页“猜你喜欢”对用户的体验影响更大，应该给于最高可用性的保障，而push推荐给于较低的可用性保障。
 2.首页“猜你喜欢” 和push推荐都使用了很大的本地 缓存，有较大的内存使用冲突而且响应的时间较长，有严重的cpu使用冲突。

 实现的目标：一方面保证重要的系统可用性低的问题，减少未来出现可用性问题的概率，最终将95线降低40%；同时提高其他的推荐产品的服务可用性和高峰吞吐率。
 1.首先将“猜你喜欢”的推荐的部分进行单独的部署，而将push的推荐以及其他的一些对于系统资源要求不高的推荐系统部署在另外的一个机器上面。
 2.对于其他的新的推荐的业务都部署在其他的机器上，以保证 首页推荐的最高可用性的业务。
 
 ### 缺点和优点
 垂直切分的主要缺点有：
 1.维护成本。首相增加了代码库，增加了一个代码库，提高了开发工程师的维护成本，另一方面，每当添加一个代码库，运维需要多维护一个代码库。
 2.代码不共享所导致的重复的编码的工作。
 
 解决重复编码的工作的问题的一个思路就是为不同的系统提供一个共享的代码库，但是这种耦合反过来可能导致部署机器中引入为部署的业务的开销。所以在共享库中需要将少静态代码的初始化开销，并将类似的缓存初始化等工作交给上层系统。总体来说，通过共享库的方式引入的开销可以得到控制。但是对于业务密集性的系统，由于业务往往是高度定制化的，共用一套代码的好处是开发工程师可以使用随时进行修改。共享代码库中不要存放易于修改的代码，这样就不需要频繁的进行升级这种场景了。所以对于业务密集型的系统，使用垂直拆分，需要考虑的是如何减少重复代码的编写。
 
 垂直分割是一种非常的简单而且有效的性能优化方式，特别适合系统中已经出现问题而又需要快速解决的场景。部署层次的分割既安全由有效。需要说明的是部署分割和简单意义上的加机器。大部分的情况下，即使不增加机器，仅通过部署分割，系统整体吞吐率和可用性都会得到一个简单的提升。就短期而言，这几乎是一个0成本的方案。对于代码层次的分割，开发工程师需要在业承接效率和可用性上做一些折衷考虑。
 
 ####恒变分离模式
 #####原理和动机
 基于性能的考虑很多时候需要将变化的和不变的数据分开。这个和面向对象是相互违背的，因为面向对象设计中，为了实现一个对象的封装，需要将一个对象中所有相关的东西封装在一个类的对象中，最终会被存放在一张表里面，即使是有部分数据的冗余。对于很多的系统中，只会处理一些变化的数据，如果将变化的数据和不变的数据放在一起，系统对于变化数据的操作会带来额外的开销。如果容易变化的数据占的比例较低的时候，这种额外的开销将会通过杠杆效应恶化系统性能。分离易变和不变的数据在对象的创建，内存的管理，网络传输中都会带来其他的复旦。将易于变化和不容易变化的数据进行分离，可以在内存管理，网络传输等方面有助于性能提高。
 
 恒变分离模式有点类似于数据库设计中的第三范式（3NF）：第三范式主要解决的问题是重复存储的问题，而恒变分离模式解决的是系统动态运行时的恒定数据重复创建传输，存储和处理的问题。按照3NF，如果一个数据表的每一个记录都依赖于一些非主属性集合，而这些非主属性集合大量重复出现，那么应该考虑对被依赖的非主属性集合定义一个新的实体（构建一个新的数据表），原数据库的记录依赖于一个新实体的ID
 。如此一来数据库重复数量将大大降低。类似的，对于一个实体，如果系统处理的只是这个实体少量的变化属性，应该静不变的属性定义为一个新实体。（运行时的另一个类或者是数据库中的另一个表），原来实体通过ID来引用新实体，那么 原有实体在运行系统中的数据传输，创建，网络开销都会大大降低。
 
 #####案例分析
 一个高性能、高一致性要求的团购服务，系统存在一些多次请求杠杆的反模式问题，，客户端的一次请求将会导致几十次的服务的调用，每次获取上百个团购详情信息，服务端每次都有每秒万次的吞吐量。
 在开始的时候，系统中只有一个表，所有的点赞信息，销量信息，价格信息，用户评价等信息频繁的发生变化，为了达到数据的一致性，每秒钟需要从数据库同步几万条记录。随着业务的增长系统会出现以下的问题：
 1.团购服务网卡频繁的报警，由于这是一个高性能底延时的服务，又导致了大量的客户端超时异常。
 2.频繁的fullGC，由于不断的读取修改团购的表，导致了对象不断的创建和销毁。
 3.数据库中读库的数据滞后于写库的数据，原因是数据库中写的数据量巨大。
 
 通过一些措施，大大降低了网络传输的数据量，缓解了主从数据库同步的压力，使得客户端的超时异常沖高峰时期的9%降低到0.1%。
 1. 将团购中的那些销量，价格用户评价等常变的信息单独的创建一张表。
 2. 同时在代码中为销量价格，用户评价等信息创建一个单独的类
 3. 对于这两张表的操作分开。
 4. 对于易于修改的表的字段将会单独的进行修改。
 
 #####恒变分离的缺点
 采用恒变分离主要有3个缺点
 1.不符合面向对象的设计原则，原本是一个对象一个实体被分为多个实体，会给开发带来一个理解上的困惑，增长了维护的成本，同时增加了引入新的bug的可能。面向对象真的非常的易于理解。
 2.类的对象的维护的难度，原有对象的封装是通过语言提供的封装的特性来实现的，当一个类变成多个类的时候，对象的不变性将会被移到易变的实体中去。对象的封装特性将会被破坏
 3.一张数据库表的变成了多张数据库表。这个增加了维护的难度。
 
 恒变分离的一些不太适合的场景：
 1，易于变化数据导致的传输和操作并不频繁。不是系统的主要的操作。
 2，易变的数据占整体的数据的比例很高，不变的数据的比例很低的时候，杠杆效能并不明显，通过恒变分离模式不能根本的解决系统分离的问题。
 
 总而言之：恒变分离模式使用的场景需要满足两个条件：易变数据在整体的数据中的比例很低（比例越低，杠杆的效果越明显），易变数据所产生的操作是整个系统中的操作是系统中的主要的操作。在一下的场景，系统的性能出现了问题，通过恒变分离就非常的有必要。
 大部分的数据结构的变化的程度分为易变，少变和布点的属性。很多时候不要盲目的进行恒变分离，这样会使得整个系统的维护性变低。所以设计系统的时候，首先按照面向对象进行设计，只有在性能出现问题的时候使用恒变分离模式。如果业务简单，性能要求高的基础服务中，恒变分离设计模式应该是一种非常重要的原则。
 
 
 ####数据局部性模式：
 #####原理和动机
 数据局部性模式是多次请求杠杆反模式的解决方案。在大数据和情调个性化的服务的时代，一个服务消费几十个不同类型数据的现象非常常见，每一种类型的数据服务可能需要一个大的集群提供服务，意味着一次调用就会产生服务端的成千上万的调用，很容易发生杠杆反模式。在具体的开发的过程中，导致数据量暴增的主要原因有两个：1.缓存的滥用以及缺乏规划；2.数据量太大以至于无法在一台机器上提供全量数据服务。数据局部性模式的核心事项是合理的组织数据服务，减少服务调用次数。具体的从服务端和客户端两方面进行优化。
 服务端的优化是对服务进行重新规划，对于数据量太大的时候无法在一台机器上存储的时候：主要有两种情况出现，首先是数据太大，太多，无法使用一台机器存放，这个时候可以使用更优秀的数据存储技术来存储相对应的数据。然后是数据本身来自于不同的地方 ，这个数据由各个生产线产生，本来存放的时候是零散的，这个时候需要做的事情是加强沟通，保证 ：数据由尽可能少的服务器来提供。2.经常一起被使用的数据放在同一个服务器上。
 
 客户端优化的手段有以下几种：
 1. 本地缓存，对于一致性要求不高的且命中率较高的数据服务，本地缓存可以减少服务端调用的次数。
 2. 批处理，对于单机或者有等价的机器集群提供的数据服务，尽可能使用批量的处理方式，将多个请求合成在一个请求中。
 
 #####案例分析：
 对于一些涉及到推荐，个性化列表和个性化搜索服务，这些个性化系统需要获取各种用户，商家和团购的信息。信息类型包括基本属性和统计属性。最初，不同属性数据由不同的服务提供，有些是RPC服务，有些是redies服务，有些是Hbase或者是数据库中，放在不同的数据源。
 
 通常客户端每个用户请求都会触发多个算法。一方面，每个算法都会召回几十甚至几百个团购的或者是商家的ID，团购和商家基础属性被均匀地分配在了几十台redies里面。产生了大量的请求，在极端的情况下redies请求进入了多次的请求杠杆反模式。reides服务器常常被卡死。
 
 #####解决方案
 1.一个大内存服务器，将所有的商家id和团购需要的数据添加到内存中，每次只要一次调用就好了。
 
 
 #####优点和缺点
 系统局部性模式并不适合于系统初级阶段。在初级阶段，最小可用原则往往是主要设计原则之一出于两方面的 考虑：一方面，在初级阶段，很难预测所要提供的服务的数据是否是长期有效的使用和未来的调用量；另一方面，在系统初始的时候可能没有办法去预估数据的使用量。对于一些关键的数据，重构都会带来可靠性，一致性和工作量都是需要权衡的因素。
 
 ####避免蚊子大炮模式
 #####原理和动机
 "用大炮打蚊子"是指大材小用的意思，可能一些小的功能需要一个小的接口就可以完成。当前的系统中有一些功能强大的接口去完成这个功能。很多时候我们可能就会使用这个接口去完成这个功能。我们不断的试图去实现一些通用的接口，尽可能多的复用一些接口，这些通用的接口会变得越来越臃肿。使用一个通用的接口能够解决一些小的问题，这是很好的，但是时长使用这种方式去解决问题会带来一些问题，就是会使得在执行的时候消耗额外的系统的资源。
  这个问题就是经济原则的在代码的开发和代码的运行两个阶段中的博弈，码农在开发的时候会尽可能的考虑代码的复用，尽可能少的代码去解决当前的问题，会追求代码开发阶段的经济性。但是使用一个通用的接口在执行的时候会需要使用更多的资源。所以我们在完成一个需求的时候，我们不仅需要考虑当前接口实现的时候是需要新开发一个专用的接口还是在现有的接口的基础上进行开发。我们在开发一个接口的时候需要权衡当前需求的预期的开发的量以及当前的接口预期的调用数量，以及如果在现有的接口上进行扩展会带来那些额外的开销。所以我们在设计接口的时候不能不加辨识的复用现有的接口，这样会带来重构的风险，还会交叉影响。

#####案例分析：
为移动用户搜索附近的商家信息。所以会有一个基于LBS的搜索服务。但是很多的搜索服务并不是使用LBS的收索也调用了基于Lbs的搜索服务。导致了LBS搜索服务的请求大增。导致LBS的搜索接口的可用性非常的差。此时将那些和LBS无关的接口抽离出来，各种专业的搜索使用专业的搜索算法，这样大大的提高了当前接口的可用性，同时减少了对于LBS搜索的接口的影响。

######缺点和优点
避免蚊子大炮模式的问题和最小可用原则相冲突。在系统设计的初期寻求最优的解决方案往往意味着过度设计。所以最优化的原则意味着 在软件工程的各个阶段之间的经济性的一个平衡.在软件的预研，设计，开发，测试，运行，维护之间都会消耗一些资源，我们需要在这6个阶段每个阶段都需要考虑经济性。
如何发现蚊子大炮的问题可以首先使用相同的代码库，然后将当前的系统分开进行部署可以快速定位问题。确定每个调用方的对当前的系统的影响。

####实时离线分离模式（Sandbox  Patern 沙箱模型）
 线上和线下对于系统的稳定性的要求是不一样的。
 
####降级模式
#####原理和动机
降级模式是系统性能保障的最后一道防线。理论上来讲，所有的系统都会有bug的存在。最好的方式是当系统出现bug时事先准备了预案。所以在设计系统的时候，会做好降级设计。降级的方案有以下的几种：
1. 在设计阶段，就要确定系统开始恶化的数据指标（例如：响应时间，内存使用量）
2. 在系统恶化的时候，需要在第一时间进行报警
3. 在收到报警的时候，或者是人工的手动控制系统进入降级状态，或者是写一个智能程序让系统自动降级
4. 区分当前系统所依赖的所有的服务的必要性和非必要性，一般分为：必要服务和可选服务。必要服务在降级状态下必须提供一个快速返回结果的权宜方案（缓存是常见的一种方案）。对于一些可选的服务在降级时系统果断的不调用。
5. 在系统的状态好转的时候需要人工恢复，或者是智能程序自动升级。

典型降级的策略有三种：流量降级，效果降级、功能降级。
1. 流量降级：是指通过主动拒绝部分流量的方式让系统正常的为部分的流量提供服务，这个会造成部分用户无法使用当前的服务。
2. 效果降级表现为服务质量的降级，即在流量高峰时期用相对低的质量，低延时的服务替代高质量，高延时的服务保证所有用户的可用性；功能降级表现为服务质量的降级，通过减少功能的方式来提高用户的服务的可用性。功能降级和服务降级有一些相似，都是保证所有的用户能够使用，两者之间的区别是：降低效果就像是优酷的视频播放，对于网络好的给于高清的播放，对于网络不好的提供低质量的播放。而功能降级例如淘宝的双十一将一些评价，查看商品评论的接口会被关闭。

其他的一些性能优化的建议：
1.对于系统中的一些无用的代码，这些代码在系统初始化的时候会占用系统中的资源。
2.避免跨机房调用，跨机房调用会带来大量的资源的消耗。

参考文献： http://tech.meituan.com/performance_tuning_pattern.html


 
 
 
 
 

 
 
 
 
 










 