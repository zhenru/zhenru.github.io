---
layout: post
title: java并发编程的读书笔记：对象的共享
---

多线程中的关键问题是一个可变的对象的访问的控制，主要是对象的可见性和对象的可变性。

####可见性

- 可见性问题导致，程序运行结果不正确。有可能由于编译器对于代码执行优化的重排序的问题。对于这些重排序在单线程的环境下会优化代码的执行，但是在多线程的情况下会带来一些问题的问题。
- 非原子的64位问题，在java中会有一些64位的基础类型，例如 LOng。其中java中默认的带宽是32位，对于64位的访问需要两次，对于这个基础对象的访问就不是原子的，就会带来多线程的问题。，
- 加锁与内存可见性。内存可见性是由于java的内存模型引起的一些问题，每一个线程在执行的过程中对于某个对象访问的时候，会将需要访问的对象读取到当前线程的执行的空间中 。当一个线程访问完一个对象以后，其他的对象是没有办法立即看见，加锁能够解决这个问题，保证每一个对象访问的对象都是最新的对象。
- volatitle变量：将一个变量声明为一个volatile的，这个能够保证任何一个线程操作完毕一个对象的时候，会将这个对象的变量写到堆上，能够被其他的线程立刻看见，同时也保证其他的线程在访问volatile对象的时候必须去堆上去读取最新的数据。但是Volatile变量只能保证可见性，但是没有办法解决原子性问题。synchronize能够同时保证原子性和可见性。
- Volatile 使用的场景：对变量的写操作不依赖于之前当前值，或者取保只有一个线程能修改变量的值，其他的线程访问当前的变量。或者是一个对象中只有一个volatile的变量，，只访问当前的变量的时候是不需要进行加锁的。

####发布与逸出
- 发布对象：是将生成的对象让其他的对象被其他的作用域外的对象能够访问。
- 安全的构造对象的过程：不要在构造过程中的时候使用this引用，这个会导致当前的对象的被其他的对象获取到。
- 线程的封闭：线程的封闭是指当前的对象只能被当前的线程访问。这就打破了对象线程安全性的共享的那个特性。

 