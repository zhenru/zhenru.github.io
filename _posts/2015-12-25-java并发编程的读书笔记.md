---
layout: post
title: java并发编程的读书笔记-简介
---



####线程安全性
 - 线程安全性是指多个线程对于*可变*的可以*共享*的对象访问的控制。其中的关键是*可变*和*共享*。`可变是指一个对象中有变量，同时这个变量是可以改变的.`.`共享指当前的对象能够被多个线程同时访问`。
 - java的同步机制：独占锁synchronize和volatile变量，显示的锁 Lock以及基础的一些原汁变量。
 - 编写并发程序的原则：代码能够正确运行；提高代码速度
 
####什么是线程安全性
- 线程安全关键是正确性：多个线程在执行的过程中是按照规的正确的状态进行执行。并没有出现不正常的状态。就是任何多个线程以各种顺序进行执行的时候都能够保证正确的输入。
- 无状态的类（这个类当中是没有外部可见的成员变量）是线程安全的。

####原子性
- 原子性是指一个线程中的多个动作要么全部执行，要么都不执行，如果没有原子性多个线程中的多个动作在执行的过程中按照不同的顺序执行的时候就会导致错误的执行。
- 原子操作：对于访问同一个状态的所有的操作（包括该操作本身）来讲，这个操作是以原子的方式执行的，
- 复合操作：包含了一组操作的时候，比如检查初始化 读取修改写入等。  即使是一组操作，这些操作都是原子操作，这一组操作也是不是线程安全的。
- 如果一个对象中只有一个线程安全的对象作为成员变量，同时对于线程安全的对象使用了线程安全的方式进行访问的话这个变量也是线程安全的。如果这个对象中包括了多个线程安全的的对象的成员变量，那么这也是线程安全的。

####加锁机制
- 将多个线程安全的变量放在一个对象中，组成的对象不是线程安全的对象。此时需要保证状态一致性，需要保证对于当前的对象中的所有的需要保证线程安全的状态的访问都需要同一，为当当前的对象中的所有的状态位要么都执行要么都不 执行。
- 内置锁， java中提供的内置锁：synchronized关键字，这个关键字会对于系统中的一个对象的引用进行枷锁，只有竞争到了锁，这个锁保护的代码段才会被执行。如果synchronized是加在一个方法上的，那么锁就是当前对象来充当锁，如果这个对象是加在了一个static的方法上面的，那么当前对象所对应的Class对象将会作为锁的对象。
- 重入：如果当前的线程获取到当前的某一个对象的锁的时候，当前的对象就一直能够进入。这种处理的方式是对于当前对象中的一个锁会被分配一个计数器。需要判断一个线程是否包含了一个锁定的时候，需要去判断一下当前的线程获取到的锁的计数器是否 = 0，如果！= 0 ， 这个线程还保有锁。如果 = 0 表示当前的锁没有人占有，需要引起锁定的竞争。
- 使用锁来保证对象的状态， 如果多个线程访问一个对象中的多个可变的变量的时候需要使用得到一把锁，这个时候，就说明这个对象中的多个变量是被这把锁保护的。【每个对象中最好只有一把锁来保护当前的状态。】

#### 活跃性于性能
- 为了提升系统的性能，不能对整个方法添加锁。如果一个方法中带有太多的锁对象的时候会导致系统的性能的下降。
- 当执行时间较长的一些操作，例如是I/O和大量的的计算 ，一定不能持有锁。


