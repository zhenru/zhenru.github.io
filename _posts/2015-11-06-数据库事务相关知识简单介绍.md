---
layout: post
title: 数据库事务相关知识简单介绍
---

- 事务是什么
事务解决了一个问题是，当数据库中的数据越来越多，结构越来越复杂，数据的共享越来越多的情况下，如何保证数据的完整性，安全性，以及数据的并发性，以及从执行过程的故障中恢复过来。，
引用百度百科的描述如下：
> * 事务（Transaction）是访问并可能更新数据库中的各种数据项的一个程序执行单元（unit）。很多时候事务通常是由数据库操作语言或者是其他的一些高级语言书写的用户程序（java 或者 SQL）引起的，使用例如`begin transaction`和 `end transaction`组成的。事务的执行就是在`begin transaction()`和`end transaction()`之间的全体操作。
>*  数据库事务是指作为单个逻辑工作单元执行的一系列的操作，。这个操作要么执行要么不执行。事务处理能够保证除非事务内部的所有的操作都顺利的完成，否则是不会去永久的更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，这样可以简化错误恢复和使得应用程序更加的可靠。一个了逻辑单位要成为一个事务必须满足ACID特性。事务是数据库运行中的一个逻辑单位，有DBMS的事务管理子系统负责事务的处理。


  事务是数据库中最为重要的一个特性，如果多个数据库的操作在`begin transaction()`和`end transaction()`之间的操作就是一个事务，在sql中，单条sql自动开启一个事务，

-  事务的特点
 事务的特点简答概括起来就*`ACID`*特性,*`ACID`*代表了是个单词的书写*`Atomicity`*,*`Consistency`*,*`Isolation`*,*`Durability`*.
 1. Atomicity
  原子性：就是对于处于一个事务中的所有的操作要么执行，要么不执行，是一个执行的基本的单元。如果在事务的执行过程中发生了中断当前事务的情况，当前的事务之前的操作都会被回滚到执行前的状态。
 2. Consistency
  一致性：就是事务的操作，不会破坏系统中数据的正确性，就是在执行的过程中不会出现数据错误,这些数据不仅仅是业务上的数据，同时也包括所有的内部的数据（例如数据库的索引的B+树的结构）。例如，在银行的各个账户中，当各个账户之间进行转帐的过程中，各个账户中的总额是不会变化的。要么是转帐成功要么是转帐失败。而不是一个转帐成功，一个是转帐失败，导致总的账户数目错误。
  3. Isolation
  隔离性：数据库中的数据并不是只有一个用户访问。当在一个时间点有多个用户线程访问同一个数据的时候，各个线程之间是如何避免相互之间做到互不干涉的。`事务的隔离性是指由并发事务所作的修改必须同其他的事务隔离开来，一个事务查看一个数据的状态要么是一个事务修改之前，要么是一个事务修改之后，绝对不会在一个事务的修改的过程中`。很多时候事务的隔离性和数据库的访问的效率是一个相互冲突的。当隔离性上升的时候，就会禁止各个事务之间并发的访问数据库中的事务此时数据库系统中访问数据的并发性就会下降，当各个事务的隔离级别较低的时候，相对的并发也会比较的高。所以数据库专家为了在数据访问的*正确性*和*吞吐性*之间作一个平衡，制定了一个事务的隔离级别，事务的隔离级别主要包括：`READ_UNCOMMITTED` , `READ_COMMITED` , `REPEATABLE_READ`,`SERIALZABLE`.四个级别。这四个级别由低到高会数据的访问越来越安全，相对的性能越来越低下.
  4. Durability
   持久性：就是当事务中执行一条Insert或者是Update，当这个***事务执行完毕***以后，这条数据的修改就会永久性的生效，即使数据库发生了灾难性的问题的时候，这个修改的数据也会生效。
   在事务四个特性中，最关键的是一致性，这个本身就是为了保证数据的正确性的，其他的三个特性都是为一致性服务的。
   
   - 事务的隔离级别简介
   在事务的四个特性中最难理解的是事务的隔离性，事务的隔离性是保证事务的一致性的最重要的手段之一。在不同的事务的隔离级别中解决了不同的问题，主要存在的问题是:`Dirty Read`,`Unrepeatable Read`,`Phantom Read`.相对应的各个问题随着事务的隔离级别的提高而得到解决。
   
   * 脏读
    脏读就是读到了垃圾的数据，具体的实现如下：
    |时间              |事务A  （存款        |事务B （取款）            |
    |-----------------|---------------------|-----------------------|
    |T1                |开始事务			  |			  			 |
    |T2				   |					 |开始事务     			 |
    |T3				   |					|查询账户的余额（1000）	  |
    |T4				   |					|取出1000，余额（0）      |
    |T5      		   |   查询余额=0	     |	  					  |
    |T6      		   |            	     |	 撤销事务（余额恢复到1000）|
    |T7     		   |   存入500元	     |	  			-		  |
    |T8     		   |   提交事务	     |	  			-	     	  |
   这个时候看上表中，如果正常的情况中账户中的最终的结果应该是1500元钱，但是最终的结果是这个账户中的余额是500元。这个问题就是事务A在时间点`T5`的时候读取了一个事务B没有提交的数值导致的。那个时间点中就是一个脏数据。
   * 不可重复读
   在一个事务中两次中读取到的数据是不一致的。
    |时间              |事务A  （存款        |事务B （取款）            |
    |-----------------|---------------------|-----------------------|
    |T1                |开始事务			  |			  			 |
    |T2				   |					 |开始事务     			 |
    |T3				   |					|查询账户的余额（1000）	  |
    |T4				   |	 查询余额=***1000***		 |                       |
    |T5      		   |  	                |	取出1000，余额（0）    |
    |T6      		   |            	     |	提交事务             |
    |T7     		   |   查询余额	=***0***    |	  			-		  |
    |T8     		   |   提交事务	     |	  			-	     	  |
   从上图中可以看到在事务A在执行的过程中，在T4的时候，查询到的账户余额是1000但是在T7的时候查询到的余额是0.这个就是不可重复读。
   * 幻读 
   幻读很多时候是读取的数据是在变化的。这个读取是一个统计的读取。是读取一张表中的数据的和。
    |时间              |事务A  （统计)        |事务B （取款）            |
    |-----------------|---------------------|-----------------------|
    |T1                |开始事务			  |			  			 |
    |T2				   |					 |开始事务     			 |
    |T3				   |统计所有账户的余额=***1000***|                 |
    |T4      		   |  	                |	账户A取出10，         |
    |T5      		   |            	     |	提交事务             |
    |T6     		   |  统计所有账户的余额	=***990***    |	  -		  |
    |T7     		   |   提交事务	     |	  			-	     	  |
    
    通过上表中查看事务A中在事务的过程中前后两次执行的过程中，返回的结果是不一样的，这个和不可重复读中的情况有点类似，都是在一个事务中读取到的数据是不一致的，在不可重复读中涉及的字段是一个字段，但是在幻读中涉及到的是一张表中的多个字段，这个是本质的不同。***银行中每天进行盘点总账户余额是如何实现的?***
    
    总结：
    ***脏读***：事务A读取了事务B还未提交的数值
    ***不可重复读***：事务A读取的数据，是使用的过程中被事务B修改了。
    ***幻读***：事务A在统计多个字段的时候，事务B将其中的一个字段改了。
    
   不同的事务隔离级别解决了上面的不同的问题，具体如下表：
    |事务隔离级别       |脏读               |不可重复读            |幻读                  |
    |-----------------|------------------|---------------------|---------------------|
	|READ_UNCOMMITED  |允许               |允许                  |允许                 |
    |READ_COMMITED    |禁止               |允许                  |允许                 |         
    |REPEATBLE_READ   |禁止               |禁止                  |允许                 |
    |SERIALIZABLE     |禁止               |禁止                  |禁止                 |
    
- 事务是如何实现的。
 在DBMS中为了实现事务提供了如下的主要技术手段和方法如下：
 
 * 把对数据库进行操作划分为称之为“事务”（或者“事务元”）的一个个原子单位。事务是事务处理的基本执行单位,即一个事务中的操作要么全部执行，要么全部都不执行，即实现所谓的`all or none`原则。一个事务一般是使用一个“开始”（begin）语句开始，先从数据库中取出一些数据，然后进行所需要的处理。最后以“提交”（commit）语句结速。如果在事务中发生了异常，则用“异常终止”(abort)语句或者“回退”(rollback)语句撤销之前所作的操作（这就是所谓的undo）将数据库恢复到开始时的正确状态，以保证数据的完整性，一致性。
 * 用户在对数据库发生请求的时候，系统会对其中的不同的粒度(granularity)的数据元素（字段，记录以至于整个文件）进行“加锁”（locking）,加锁的数据将会禁止其他的用户访问当前的数据（这只是简单的描述，事实上，根据用户对数据的请求的不同，加锁的数据对待请求的方式是不同的，例如，如果枷锁的数据将会执行修改的操作，对于其他的执行请求是不会响应的，；而如果锁住的数据是被读取的，那么对于其他的读出的请求还是允许的。这就是所谓的锁相容特性）。操作完成以后进行“解锁”。这中机制既保证了事务之间的“并发性”，同时也保证了数据的完整性。
 * 建立系统允许日志（log），记载各个事务的始点、终点以及事务开始执行前后的表的状况（beginImage和afterImage）以便当数据库系统出现状况的时候能够根据定期和不定期的为数据库操作所作的备份（backup）加上日志将数据库恢复到系统事故前的正确的状态，同时也能保留最后一次备份以来的对数据库所作的操作。
 * 对数据库的任何更新分两阶段提交（two-phase-commit）.这是基于一个事务涉及到两个不同的数据库系统而必须的，这在分布式系统中非常重要的。




参考文献
1. [百度百科-事务](https://www.tapd.cn/20006991/prong/iterations)
2. [百度百科-数据库事务](http://baike.baidu.com/link?url=9_WTyfaF7et0vz58vFY4sRBPqqYRy602l_60zlzQWScbs04U9nB9Kyv0QIq-wTF3d26fQIL-G20-RakK5ZHeza)
3. [百度百科-詹姆斯·尼古拉·格雷](http://baike.baidu.com/link?url=1sAsHvDvy8uITnxndKbWrC-O1l-yo_WFz1-REOF3zRlRY1ryUZnejrJlp5TFr4kjo-a4qYiPfbu9HVRxu9Morq)
